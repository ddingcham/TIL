# 원글 : [의존성 끊기와 단위 테스트 - 조영호님](http://aeternum.egloos.com/2598831)  

#### [회고 시점 1. 주문 도메인 엔티티 리팩토링](https://github.com/ddingcham/MayakAgain/commit/901c2e9ade47a485270a7e7627566fc3c6ceb1f2)  
#### [회고 시점 2. Working Effectively with Legacy Code 처음 읽고](https://github.com/ddingcham/withLegacy)  

## 1-1. 단위 테스트 표류기  
```
Order 객체를 테스트하기 위해서는 Order 객체와 연관 관계를 맺고 있는
Customer 객체, OrderLineItem 객체, Product 객체가 필요하다.
끝없는 연관 관계의 미로 속을 헤매다 정신을 차려 보면 작은 단위테스트 안에
커다란 객체 그래프를 몰골 사납게 꾸겨 넣은 채 끙끙 거리고 있는 자신을 발견하게 된다.
```

* 커다란 객체 그래프를 대상으로 수행되는 단위 테스트  
  * **에러 위치 확인(Error Localization)**  
    > 클래스를 고립시키면 제한된 부분만 ... 에러의 원인을 파악하기가 쉽다.  
      >> 여러 클래스를 가로지르는 실행 경로를 살펴보면서 ...  
      >> 테스트에 대한 애정이 조용히 사라지는 것을 느끼게 된다.  
  * **실행시간(Execution Time)**  
    > 만약 내부의 특정 객체가 ... 외부 리소스에 의존하고 있다면  
      >> 수행 시간은 기하급수적으로 늘어난다.  
      >> 테스트를 수행하는 횟수가 줄어든다.    
    #### 건강한 피드백 루프의 장점이 손상된다.  
    
  * **테스트 커버리지(Coverage)**  
    > 거대한 객체 그래프의 특정 코드를 수행하기 위해서 ...  
      >> 보다 특정 클래스에 포함된 단일 메소드를 실행하기 위해 필요한  
      >> 입력 값을 찾는 것이 쉽다.  
      
#### 단위 테스트의 효과를 극대화시키기 위해서는 클래스를 고립시켜야 한다. -> 의존성을 끊기 위한 기법  

## 1-2. 의존성 끊기(Breaking Dependency) 게임  

#### 의존성(Dependency)  
> : 두 요소간의 관련성으로 한 요소에 대한 변경이  
> 다른 요소가 필요로 하는 정보를 제공하거나  
> 다른 요소가 제공하는 정보에 영향을 주는 관계  

* 클래스가 다른 클래스의 인스턴스를 속성으로 포함하는 경우  
* 메소드의 파라미터로 사용하는 경우  
* 메소드 내부에서 지역적으로 인스턴스를 생성하는 경우  
* 다른 클래스를 상속받는 경우 모두 두 클래스 간에 의존 관계의 형성된다.  

Order 클래스가 Customer, OrderLineItem, Product 에 의존하고 있다면
의존하고 있는 모든 객체들을 포함하는 거대한 객체 그래프를 생성해야 할까?  

#### 단위 테스트의 가장 큰 적은 클래스 간의 의존성이다.  
#### 객체 그래프 상의 적절한 위치에서 의존성을 제어할 필요가 있다.  

## 2. 인프라스트럭처와의 결합  
```
코드를 처음 보았을 때 받은 첫 느낌은 코드 전체적으로 Apache Hadoop이라는 인프라 스트럭처에 너무 단단하게 결합되어 있었다는 점이다.
따라서 Apache Hadoop이 실행되지 않는 분산 클러스터 외부에서는 특정 클래스의 인스턴스를 생성하거나 메소드를 실행하기가 불가능했다.
```

#### 인프라스트럭처에 의존성을 가지지 않는 유틸리티 성 클래스로 그 영역이 제한될 수 밖에 없었다.

* JobConf와 JobClient는 Apache Hadoop 클래스터 환경이 정상적으로 실행 중이어야만 인스턴스 생성 및 실행이 가능하다.  
  ![](http://pds18.egloos.com/pds/201009/24/18/f0081118_4c9c97424eaa4.jpg)  

* **의존성을 끊기 위해서는 현재 무엇을 테스트하고자 하는 지를 생각해야 한다.**  
  > ... 주된 작업은 Map-Reduce 작업을 수행할 분산 파일 시스템 상의  
  > **입력 파일과 출력 파일의 경로를 구하는 것이다.**  
  #### 따라서 입력 파일과 출력 파일의 경로를 구하는 로직을 인프라스트럭처에 대해 독립적으로 구성하면 된다.  
  
* LogDailyAnalyzeJob이 **오직 인터페이스**에 대해서만 의존하도록 코드를 리팩토링한다.    
  ![](http://thumbnail.egloos.net/600x0/http://pds20.egloos.com/pds/201009/24/18/f0081118_4c9c979ab9fc4.jpg)  

* JobConf에 설정할 값들을 제공하기 위해 JobConfiguration 인터페이스를 추가한다.  
  > JobConf에 설정된 다양한 값들을 계산하여 반환하는 역할을 수행한다.  
  > 일간 작업과 관련된 모든 로직이 DailyJobConfiguration으로 이동 -> 좀 더 일반적인 LogAnalyzeJob으로 변경  
  
  ![](http://pds20.egloos.com/pds/201009/28/18/f0081118_4ca0b340b488c.jpg)  
  
## 3. 의존성 끊기와 설계  
```
일반적으로 클래스 간의 의존성을 제어하여 테스트 용이성을 향상시킬 경우
결과적으로 시스템의 설계를 개선시킬 수 있는 가능성이 높아진다.
```

* 대부분의 코드가 중복되어 있었다.
  * ... 일/주/월간 ... 통계를 테스트하기 어려웠을 뿐만 아니라,  
  * 절차적인 방식의 설계와 코드 중복으로 인해 확장 및 유지보수가 어려움  
  ![](http://pds18.egloos.com/pds/201009/28/18/f0081118_4ca0b380112bd.jpg)  
  
* (2. 에서) 의존성 제어를 통해 테스트 가능하도록 구조를 개선한 후  
  * 코드 중복이 없으며  
  * 코드 수정 없이도 새로운 기간의 통계 처리 추가  
    * **Open-Closed Principle** 만족하는 구조  
    
  ![](http://pds18.egloos.com/pds/201009/28/18/f0081118_4ca0b3c7b4272.jpg)  
  
  
#### 의존성 끊기 게임을 수행할 경우 얻는 장점
#### 1. 목적 자체가 테스트를 용이하게 하는 것이기 때문에 ... 단위 테스트 작성이 용이한 구조  
> 더 빠른 피드백, 문제 없이 전진할 수 있다는 용기/안정감  
#### 2. 전체적으로 응집도가 높고 결합도가 낮은 설계  
> 조금 더 객체-지향 원칙을 지키는 품질 높은 코드  

## 4-1. 프로그램과 의존성([원글 참조 필수](http://aeternum.egloos.com/2613564))  
```
불행하게도 프로그램에 대한 텍스트 메타포는 높은 응집도와 낮은 결합도, 캡슐화와 같은 훌륭한 설계가 갖추어야 하는 기본 덕목을 설명하기에는 적절하지 않다. 
애플리케이션 설계를 적절한 추상화의 발견과 복잡한 의존성의 제어라고 요약할 때, 
프로그램을 다른 각도에서 바라볼 경우 의존성을 제어하기 위한 체계적인 접근 방법을 적용할 가능성이 높아진다.
```
#### 프로그램은 이야기를 담고 있지만 그 이야기는 평면적이지 않다.

## 4-2. SEAM 과 의존성 제어  
> SEAM이란 코드를 수정하지 않고도 프로그램의 행위를 변경할 수 있는 지점을 의미한다.  
> \- Michael Feathers, **Working Effectively with Legacy Code**  

#### 단위 테스트 관점에서 SEAM  
> 테스트 대상 코드를 수정하지 않고도 테스트 실행 중에 다른 코드로 대체할 수 있는 부분  
  * 컴파일 단계 행위 대체 -> PREPROCESSING SEAM  
  * 링크 단계 행위 대체 -> LINK SEAM  
  * 실행 시(Runtime) 행위 대체 -> OBJECT SEAM
  
  #### 대부분의 객체 지향 언어의 경우에는 OBJECT SEAM 을 사용하는 것이 적절하다.  
  
#### 실제로 어떤 객체를 가리키는 지는 코드의 전후 관계 또는 실행 시의 설정을 살펴보아야만 한다.  
> **코드의 전후 관계 또는 실행 시의 설정**를 블랙박스 취급하는 이유가 있다.  

// JAVA : virtual method invocation
```
객체 지향 프로그램의 실행 구조는 소스 코드 구조와 일치하지 않는 경우가 종종 있다. 
코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들을 포함한다. 
그러나 프로그램의 런타임 시 구조는 교류하는 객체들에 따라서 달라질 수 있다. 즉, 이 두 구조는 전혀 다른 별개의 독립성을 갖는다. 
하나로부터 다른 하나를 이해하려는 것은 생태계의 동적인 성질을 식물과 동물과 같은 정적 분류 구조를 바탕으로 이해하려는 것과 똑같다.

- GOF, Design Patterns
```

## 5-1. 테스트 용이성을 향상시킬 수 있는 지침 // 설계 향상에도 도움  

#### 구현이 아닌 인터페이스에 따라 프로그래밍하라  
> 런타임에 서로 다른 구현체를 좀 더 자유롭게 플러그 인 할 수 있다.  
  >> 구현 세부사항을 변경할 수 있는 OBJECT SEAM을 손쉽게 추가할 수 있는 설계적 유연성을 제공  
  
#### 상속보다는 합성을 사용하라  
// 클래스 간의 관계, 객체 간의 관계 라는 표현을 굳이 나눠서 표현한 이유에 주목  
* 상속  
  > 상속은 **클래스와 클래스 간의 정적인 관계**를 통해 기능을 재사용  
  > 컴파일 시점에 고정  
  
* 합성  
  > **객체와 객체 간의 동적인 관계**를 통해 기능을 재사용하며 두 객체 간의 관계가 고정적이지 않고 실행 시간에 변경 가능하다.  
  
```
상속의 경우 컴파일 타임에 관계가 고정된다는 사실을 기억하자. 
따라서 상속을 사용하기 위해서는 실행 시점이 아닌 컴파일 시점에 ENABLING POINT를 제공해야 한다는 제약이 따른다. 
따라서 OBJECT SEAM을 추가하고자 한다면 가능하면 상속 보다는 합성을 선택하고 객체와 객체를 조합하는 위치에 ENABLING POINT를 제공하도록 하자. 
이를 위한 가장 훌륭한 방법은 STRATEGY 패턴을 이용하는 것이다.
```

#### static 메소드와 singleton 의 사용을 피하라  

#### 의존성을 고립시켜라  

#### 의존성을 요청하지 말고 주입하라  
(IoC 를 위한) DEPENDENCY LOOKUP과 DEPENDENCY INJECTION  
// 직접 의존하지 않더라도 객체 탐색 매커니즘에 대해 의존한다는 점은 직접 생성하는 방식이나 DEPENDENCY LOOKUP 방식이나 다를 바가 없으니  

```
DEPENDENCY LOOKUP의 경우에는 사용하려는 객체에 대한 의존성은 제거하지만 객체 탐색 메커니즘에 대한 의존성은 여전히 존재한다. 
DEPENDENCY INJECTION이 OBJECT SEAM에 대한 ENABLING POINT를 제공하기 위한 가장 간단하면서도 최적의 방법이다.
```

## 5-2. 의존성 끊기와 단위 테스트  
#### SEAM을 고려해서 작성된 코드는 높은 응집도와 낮은 결합도를 가지고 있으며  
#### 적절한 책임을 지닌 작은 객체들로 구성된 캡슐화가 잘 된 코드다.
#### 훌륭한 코드를 작성하는 개발자로 성장하고 싶은가?  
#### 그렇다면 테스트 가능한 코드를 작성하기 위해 노력하라.
#### 테스트 가능한 코드가 곧 훌륭한 코드일 가능성이 높다.