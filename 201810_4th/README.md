# 201810_4th
## [로또 게임 TDD 연습](https://github.com/ddingcham/lotto)
* 기본 TDD cycle 연습 **Red-Green-Refactor**
* 객체지향 생활체조
* [알리바바 코딩 가이드](https://github.com/ddingcham/Alibaba-Java-Coding-Guidelines)

## 20181029
### 계획
* step 1 요구사항 정리
* step 1 진행 

### 기록
* 브랜치 관리하면서 진행하기로 함

> [참고](https://www.slipp.net/questions/9)

* 이전에 [사다리게임]() 구현 하면서 느낀 점을 토대로 작업 제약사항을 추가해서 진행 하기로 함

>
Out - In 방식으로 접근하려 했더니 생각보다 전체 OutLine 잡는 게 어려워서  
꼭 필요하지만 작은 몇 개의 요구사항 구현을 먼저 진행하기로 함  
구현한 작은 요구사항들(In)을 토대로 Out을 수정 하고, 
전체 OutLine이 수정될 때마다 지속적으로 리팩토링 작업을 하기로 함  

* TDD 작업 시 작업 순서에 대해서 많은 경험을 하고 싶다. -> 나만의 노하우

## 20181030
### 계획
* step 1 에 대한 클라이언트를 TDD로 구현
* 클라이언트 TDD 진행과 리팩토링 진행

### 기록
* 클라이언트 코드 작성을 병행하면서 느낀 점

> "테스트 코드는 프로덕션의 최초 고객"  
> // OkkyCon Real TDD : 양완수님  
> 테스트 대상 파악이 힘들어서 도메인을 사용하게 될 클라이언트를  
> TDD 도중 작성하는 방식으로 진행했는데,  
> 미처 파악하지 못했던 요구사항과 리팩토링 대상이 보이기 시작함.....  
> 프로덕션을 호출하는 최초 고객(테스트 대상)이 생각이 안나면  
> 예상 고객(클라이언트) 작업도 병행하면 좋을 듯함.

## 20181031
### 계획


### 기록

* 다음에 할 것  

> 조영호님의 DDD 시리즈  
> http://toby.epril.com/?p=923  
> http://aeternum.egloos.com/1316318#2144129  

## 20181101
### 계획
* 로또 step 2

### 기록

## 20181103
### 계획
* 로또 리팩토링

### 기록

* 좋은 징조? 나쁜 징조?

> 두 달 전에 참고했었던 자바지기님 코드와 유사하게 모델링 됨....  
> 분명 고민 엄청하면서 코드 작성했었는데 ... 왜 유사하게 나왔는지 ?  
> 고민을 잘한 건지 / 아니면 기억에 의해 기계적으로 나온 건지  
> 다른 프로젝트로 다시 또 해봐야겠음

* STANDALONE CLASS 패턴

> 도메인 API 설계에 대한 고려 사항
```
PATTERN & PRINCIPLE

STANDALONE CLASS

소프트웨어에서 발생하는 문제의 원인은 대부분 의존성(dependency)과 관련 있다. 단위 테스트를 작성하려고 하는데 테스트 대상 객체가 데이터베이스에 의존하고 있다면 테스트를 작성하기가 어려워 진다. 공용 인터페이스를 수정하려고 하는데 인터페이스에 의존하고 있는 클래스들이 많다면 인터페이스를 수정하기 어려워 진다. 라이브러리의 버전을 변경하려고 하는데 라이브러리에 의존하는 코드가 애플리케이션 여기 저기에 흩어져 있다면 변경하기가 어려워 진다.

낮은 결합도와 높은 응집도라는 소프트웨어 설계 구호는 의존성의 딜레마를 잘 보여준다. 결합도가 높아지면 소프트웨어를 이해하고 유지보수하기 어려워진다. 따라서 낮은 결합도를 유지하는 것이 좋다. 그러나 응집도를 높이기 위해서는 어느 정도의 결합도는 유지해야할 필요가 있다.

따라서 문제의 초점을 적절한 의존성과 부적절한 의존성을 구별하는 방법으로 옮기는 것이 적절할 것이다. 의존성이 많아지면 객체를 이해하기가 어려워진다. 의존성이 많다는 것은 한 번에 생각해야 하는 개념의 수가 증가한다는 것을 의미한다. 인지 과부하를 초래하는 모든 의존성은 공공의 적이다. 얽히고 설킨 의존성 더미 속에서 핵심 개념을 찾기 위해 동시에 생각해야할 경우의 수에 압도당하고 있다고 느낀다면 의존성이 너무 많다는 증거다.

소프트웨어 개발은 저글링(juggling)과 유사하다. 한 번에 여러 개의 공을 공중에 띄워 놓기 위해 발버둥치지만 그 수가 한계치를 넘어서는 순간 모든 공이 땅에 떨어지고 만다. 한 번에 다룰 수 있는 공의 개수를 조절하는 것이 의존성 관리의 핵심이다.

STANDALONE CLASS 패턴의 목적은 극적으로 낮은 결합도를 유지하는 것이다. 만약 어떤 개념을 이해하는데 다른 개념이 불필요하다면 이를 제거하라. 불필요한 인지 과부하의 요인을 제거함으로써 개발자가 문제의 핵심을 효과적으로 다룰 수 있도록 하라.

STANDALONE CALSS가 외부 의존성을 완전히 제거한다는 것을 의미하는 것은 아니다. 핵심은 불필요한 개념을 없앰으로써 한 번에 처리할 수 있는 개념의 수를 극적으로 낮춘다는 것이다. 따라서 표준 정수형이나 문자열과 같은 기본 타입이나 JDK에서 제공하는 표준 라이브러리에 대한 의존성은 정신적 부담을 지우지 않기 때문에 제거할 필요가 없다.

STANDALONE CALSS가 다루는 의존성이 물리적인 의존성이 아니라 개념적인 의존성을 의미한다는 점에 주의해야 한다. Money에 있어 반올림 모드는 통화를 처리하기 위한 핵심 개념이다. 따라서 만약 표준 라이브러리에서 RoundingMode를 제공하지 않는다면 기존의 방식대로 Rounding이라는 개념을 만들고 Money가 Rounding에 의존하도록 만드는 것은 문제가 되지 않는다. 오히려 Rounding을 명시적인 개념으로 만들지 않을 경우 모델 내에 반올림이라는 개념이 암시적으로 존재하게 되어 암시적인 개념을 찾기 위한 개발자의 정신적 부담이 증가하게 된다.

Money는 Currency나 RoudningMode와 같이 표준 라이브러리에 속하는 클래스들에만 의존하도록 함으로써 Money를 이해하는데 필요한 개념의 수를 줄인다. Money를 통해 STANDALONE CLASS 패턴의 장점을 느껴보기 바란다. 
```
