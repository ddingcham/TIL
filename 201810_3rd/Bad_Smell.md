#### Bad Smell 관련 [참고 서적](https://wikidocs.net/book/55)
##### 개선사항 찾기 전 나쁜 냄새에 대한 복습
##### 읽으면서 **객체 지향 생활 체조 원칙**이 왜 그런 가이드를 제시하는 지 생각

* 중복 코드

> 한 클래스의 서로 다른 두 메소드 간의 중복 코드
>> Extract Method
  
> 동일한 수퍼 클래스를 갖는 두 서브 클래스 간의 중복 코드
>> Extract -> Pull up Method

> 똑같진 않지만, 비슷하다면 그 부분만 분리할 수 있는지 살펴 본다
>> Extract -> Form Template Method
  
  
> 같은 작업을 하지만 다른 알고리즘을 사용한다면
> >명확한 것 선택 후 -> Substitute Algorithm

> 서로 관계 없는 두 클래스 간의 중복 코드
>> 한쪽 클래스에서 Extract Class를 한 후 양 쪽에서 새로운 클래스 사용을 **고려**  
>> // 고려라는 단어가 괜히 나온 게 아닐 듯

* 긴 메소드

> 어떤 것에 대해서 주석을 달아야 할 필요를 느낄 때마다 메소드 작성
>> 메소드의 길이가 아닌 메소드가 하는 일과 일을 처리하는 방법 간  
>> **의미적 거리 - semantic distance**에 주목

> 대부분의 경우
>> 메소드의 길이를 줄이기가 목적이라면 Extract Method

> 메소드에 파라미터와 임시변수가 많다면
>> 임시변수는 Replace Temp with Query 사용  
>> 긴 파라미터 리스트는 introduce Parameter Object, Preserve Whole Object 사용

> 여전히 임시변수와 파라미터가 많다면
>> Replace Method with Method Object라는 중장비 사용

> 뽑아낼 코드 덩어리의 식별
>> 주석 찾기, 조건문, 로프 등이 메소드 추출이 필요하다는 신호를 준다.

> 조건식을 다루기 위해서는 Decompose Conditional 사용한다.

> 루프의 경우는 루프와 그 안의 코드를 추출하여 하나의 메소드로 만든다.

* 거대한 클래스

> 클래스 하나가 너무 많은 일을 하려 할 때는 보통 지나치게 많은 인스턴스 변수가 나타난다.

> 많은 변수를 묶기 위해 Extract Class를 사용할 수 있다.
>> 클래스 내에서 서로에게 의미가 있는 변수를 골라서 묶는다.  
>> 변수들 간 어떤 부분 집합에 대한 공통적인 접두사, 접미사가 있으면 클래스를 따로 뽑아 낼 수 있다.

> 만약 새로 만들 클래스가 서브 클래스로서 의미가 있으면
>> Extract Subclass가 더 쉽다는 것을 알 수 있다.

> 어떤 때는 클래스가 모든 인스턴스 변수를 항상 다 사용하지 않는다.
>> 이런 경우 Extract Class, Extract Subclass를 여러번 적용할 수 있다.

> 많은 변수를 가진 클래스와 마찬가지로, 코드가 많은 클래스에 대한 해결책은
>> Extract Class, Extract Subclass 이다.

> 클라이언트(Test Code가 될 수 도 있음)가 클래스를 어떻게 쓰게 할 것인지를 결정하고
>> 각각의 사용방법에 대해 Extract Interface를 사용하는 것이다.

> 다음은 클래스를 어떻게 분해할 지에 대한 아이디어를 준다.
>> 큰 클래스가 GUI 클래스라면 데이터와 동작을 별도의 도메인 객체로 옮길 필요가 있다.  
>> 이 때, 양쪽에 약간의 중복된 데이터를 유지하게 하고, 데이터를 동기화 해주는 것이 필요하다.  
>> Duplicate Observed Data가 이 작업에 대한 인사이트를 제공해준다.

* 긴 파라미터 리스트

> 긴 파라미터 리스트는 이해하기도 어렵고  
> 일관성이 없거나 사용하기 어려울 뿐만 아니라  
> 다른 데이터가 필요할 때마다 계속 고쳐야 하기 때문에 짧은 것이 좋다.

> 객체에 요청하여 파라미터의 데이터를 얻을 수 있으면
>> Replace Parameter with Method 사용하기

> 객체는 필드일 수도 있고, 다른 파라미터일 수도 있다.  
> 한 객체로부터 주워 모은 데이터 뭉치를 객체로 래핑 하기위해  
>> Preserve Whole Object를 사용

> 객체와 관계 없는 여러 개의 데이터 아이템이 있으면
>>Introduce Parameter Object 사용

> 예외 사항
>> 호출당할 객체와 큰 객체 간 Dependency를 만들고 싶지 않은 경우  
>> : 데이터를 하니씩 풀어서 파리미터로 넘기는 것이 현명하지만, 고통이 따른다.  
>> Dependency를 만들고 싶지 않은 경우가 어떤 트레이드 오프 사이에서 결정된 건지 고민 필요성

* 확산적 변경

> #### 한 클래스가 다른 이유로 인해 다른 방법으로 자주 변경되는 경우에 발생  
>> 만약 **어떤 클래스**를 보고  
>> "새로운 데이터 베이스를 추가할 때마다 항상 이 세 개의 메소드를 수정해야 하는 군"  
>> "새로운 어음이 있을 때마다 항상 이 네 개의 메소드를 변경해야 하는 군"  
>> 하고 말한다면, 하나의 **어떤 클래스** 보다는 분리하는 것이 더 좋은 상황에 있는 것이다.  
>> 특정 원인에 대해 변해야 하는 것을 모두 찾은 다음,  
>> Extract Class를 사용하여 따로 하나로 묶어야 한다.

* 산탄총 수술

> 변경을 할 때마다 많은 클래스를 조금씩 수정해야 한다면 산탄총 수술의 냄새를 풍기고 있는 것

> Move Method와 Move Field : 변경해야 할 부분을 모두 하나의 클래스에 몰아 넣기

> 기존의 클래스 중에서 메도스나 필드가 옮겨갈 적절한 후보가 없다면 새로 하나 만들어라

* 기능에 대한 욕심

> 객체의 가장 중요한 요점은 데이터와 데이터를 사용하는 프로세스를 하나로 묶는 기술  
> 메소드가 자신이 속한 클래스보다 다른 클래스에 관심을 가지고 있는 경우는 냄새의 신호
>> 객체의 가장 중요한 요점은 **행위**, **행위에 필요한 데이터**, **행위를 위한 메시지**  
>> 이 게 내 생각이라서 고민 발생

> #### 어떤 값을 계산하기 위해 다른 객체의 get 메소드를 호출하는 경우
>> Move Method

> #### 메소드의 특정 부분만 이런 욕심으로 고통 받는다면
>> 욕심이 많은 부분에 대해서 Extract Method -> Move Method

> #### 한 메소드가 여러 개의 클래스의 기능을 사용하는 경우, 어느 클래스로 옮길까?
>> 경험적인 방법 : 어떤 클래스에 있는 데이터를 가장 많이 사용하는 가를 기준으로
>
> 물론 이런 규칙이 깨지는 몇 몇 복잡한 패턴도 있다.
>> Strategy Pattern / Visitor Pattern / Self Delegation_[Kent Beck]  
>> 
> 확산적 변경과 싸우기 위해서는 어쩔 수 없음
>> 가장 기본적인 규칙은 **같이 변하는 것**을 모으는 것  
>> 
> 이런 예외의 경우는 동작을 옮겨서 한 곳에서만 변하도록 한다.
>> Strategy 와 Visitor는 인디렉션을 사용하여 몇 몇 기능을 독립시킴으로써, 동작을 쉽게 변경