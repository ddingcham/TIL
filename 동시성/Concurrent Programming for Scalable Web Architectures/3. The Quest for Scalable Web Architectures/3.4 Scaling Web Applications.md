# Concurrent Programming for Scalable Web Architectures  
# 3.4 Scaling Web Applications

## Intro  

#### Focus on scalability within web architectures based on the usage of concurrency   
* inside web servers  
* inside application servers  
* backend storage systems  

#### brief Overview of factors relevant for web site setup and client-side web application design  

#### See Also  
* Yahoo Developer Network: [Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html?guccounter=1&guce_referrer=aHR0cDovL2JlcmIuZ2l0aHViLmlvL2RpcGxvbWEtdGhlc2lzL2NvbW11bml0eS8wMzRfc2NhbGV3ZWIuaHRtbA&guce_referrer_sig=AQAAANoGWkIqp783ctOOuu2RwsbUYBdGoz9O8jswzJN1Sh5-GV3kkrPLd_e5bnmN7z16CT0oAOEMmti25Q8ClzSpWjnPvDt2QmGDNhNb7rIq3cykQM7G5YHl3uZq6_acce0gsss3WekX7g_XN7QLJBio8tPBVytMl_4PgxN1VYiwa0Rh)  
  > 구현(설정) 세부 고려 요소  
* ALLSPAW, John ROBBINS, Jesse:  
  > Web Operations: Keeping the Data On Time, O'Reilly Media (2010)
* ABBOTT, Martin L. FISHER, Michael T.:  
  > Scalability Rules: 50 Principles for Scaling Web Sites, Addison-Wesley Professional (2011)
* ABBOTT, Martin L. FISHER, Michael T.:  
  > The Art of Scalability: Scalable Web Architecture, Processes, and Organizations for the Modern Enterprise, Addison-Wesley Professional (2009)  
  
  
#### 사용자 관점에서의 확장성  
> 사용자 수와 부하에 관계 없이 **동일한 품질의 서비스 기능 제공**  
* 사용자 경험과 실제 서비스 부하와의 상관 관계가 없어야 함  
  > 추론되선 안됨.  
  > 구체적으로, 서비스 부하량 증가 -> 웹 서비스에 대한 사용자 경험 악화 로 확산되는 상황 막아야 함  
* key : **일정(constant)하게 낮은 latency reponses 유지**  

#### low round-trip latencies of single request / response cycles are essential.  

#### 복잡한 모델이 필요함 : 동적 콘텐츠 응답을 위한 전체 단계들을 모두 수행하지 않기 위해  
> 1) 자주 하고, 공통된 작업을 중간중간 끼워 넣음  
> 2) 한 번에 모든 작업을 하지 않고, 단계를 나눔  
> 그 사이 사이에 새로운 컴포넌트 / 멘탈 모델이 추가됨 ...  
> 그런 상황에서 복잡함을 줄이기 위해 필요한 점들 앞에서 다뤘음  

* ex] asynchronous loading of new content and partial update of the user interface  
> AJAX 활용 느낌 (모든 게 로드되지 않아도 됨)  
> 처음 단계에 꼭 필요한 것만 처음에 로드되도록 (필요한 것 : 사용자 관점에서 필요한 것)  

## Optimizing Communication and Content Delivery  
#### it is very important to minimize the number of HTTP requests  

#### Network round trip times  
* can dramatically increase latencies  
* can dramatically slow down the UX.  

### Approaches : as few as requests  

#### approach 1 (popular) : CSS sprites and images maps  
* Loading a single image file containing multiple smaller images  
* 클라이언트 사이드에서 조각들을 분할하고 배치/랜더  
* provide a single image containing all button images and graphical user interfaces elements  

#### approach 2 : inlining of external content  
* smaller images can be directly inlined into an HTML documents  
  > arbitary content as a **base64-encoded URI string**  
* Browsers often limit the number of **parallel connections to a "certain host"**  
  > When multiple resources have to be accessed, it can help to **provide several domain names for same server**  
  > (static1.example.com - static2.example.com)  
  > RFC 2616   
  > FIELDING, R.; GETTYS, J.; MOGUL, J.; FRYSTYK, H.; MASINTER, L.; LEACH, P. BERNERS-LEE, T.:   
  > Hypertext Transfer Protocol - HTTP/1.1, RFC 2616 (Draft Standard) (1999), updated by RFCs 2817, 5785, 6266  

#### approach 3 (important, strategy side) : embrace caching  
> static assets should be indicated as not expiring  
> images, stylesheet files, JavaScript files ... etc  

* they get replaced by other assets when the site gets updated.  
  ** This yields some immutable character for static assets**  
  > allows us to cache aggressively.  
  
* **For dynamic content, web servers should provide useful headers**  
  > allowing conditional semantics in subsequent requests.  
  * ETag  
  * Last-Modified  
  
* **Reverse caching proxies can also cache** generated content -> speed up responses    
  
#### CDN : Content Delivery Network  
> Microsoft Azure doc : [CDN 사용에 대한 모범 사례](https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/cdn)  

**CDN helps to off-load the machines serving static assets and shortens response times.**  

**JavaScript library 에 적용 하는 것도 매우 효율적**  
> WebPack 설정을 CDN 베이스로 적용 ? -> "externals"    
> https://webpack.js.org/configuration/externals/  



