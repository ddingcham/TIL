# Concurrent Programming for Scalable Web Architectures  
# 6. Concurrent and Scalable Storage Backends  

## 6.3 Types of Distributed Database Systems  

### Relational Database Management Systems  

* **The implications of the ACID paradigm combined with distributed systems**  
  **make it very difficult to build ditributed data base systems based on the relational model**  

  * Requiring the usage of complex mechanisms such as distributed transactions  
    > that are feared by many developers  
  * Enforcing ACID properties requires high complexity costs  
  * ACID properties promptly hinder low latency and high availability  
  
* **distributed joins make distribution so painful**  
  > While replication and especially partitioning provide the basic tools for scaling out  
  * in a single instance db, join operations can be efficiently handled thanks to **Data Locality**  
  * **in a distributed database systems**  
    * joins may require potentially large amounts of data to be copied between nodes  
      > in order to execute the necessary table scans for the join operations  
    * This overhead renders such operations in many cases unusable  
  * join operations are an inherent feature of the relational data model  
    > **can not be easily abandoned**  
    > 엄청난 노력이 필요할 수도 있고, 복잡하지만  
    > 오랜 기간동안 성숙한 기술을 쉽게 포기할 순 없음  
    > 기술을 받쳐주는 생태계도 같이 성장했을거니까 ...   
    
#### ex] MySQL  
> very popular for web applications  
> **supporting multiple backend storage engines**  
> 요즘엔 다양한 상황들에 각각 적합한 솔루션들이 존재  
> 어떤 문제(read concurrency issue)를 해결하기 위해 어떤 기능을 지원하는 솔루션(MySQL)을 선택하는 지 접근 방식 위주로 생각  
* Providing a simple yet powerful strategy using a **master-slave architecture and replication**  
  > Many web applications primarily struggle with read concurrency and scalability in terms of user load  
  * Read-only operations(SELECT) are load-balanced to one of the slaves  
  * operations containing Write are forwarded to the master  
    * **Updates are then asynchronously replicated from the master to the slaves**  
  * This remove unnecessary load from the master, and **helps to scale read operations**  
    > un-Scalability for write operations  
  * Master-slave setups can be further scaled using partitioning strategies and more complex replication setups  

* **MySQL Cluster**  
  * based on a **shared nothing architecture of nodes**  
  * using synchronous replication combined with automatic horizontal data partitioning  
  * Nodes can be either  
    * **data nodes** for storage  
    * or **management nodes** for cluster configuration and monitoring  
    
### Non-Relational Database Management Systems  
