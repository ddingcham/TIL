# Concurrent Programming for Scalable Web Architectures  
# 4. Web Server Architectures for High Concurrency  

## 4.3 The Case of Threads vs. Events  

#### we take some time for a closer look on the general argument of threads vs. events.  

* Duality Argument : intrinsic relationship (threads & events)  

* neutral view on both models and conclude on their strengths and weaknesses  

### The Duality Argument  

#### comparing message-oriented systems with procedure-oriented systems.  
> LAUER, Hugh C. NEEDHAM, Roger M.:  
> On the duality of operating system structures. SIGOPS Oper. Syst. Rev. (1979),  13: 3-19  

* message oriented system  
  * system uses a small number of processes  
  * a process uses explicit messaging  
  * system is similar **event-driven system**  
* procedure-oriented system  
  * system is based on large numbers of small processes  
  * a process uses shared data  
  * system is similar **thread-based system**  
  
* Main contribution  
  > semantic 은 같고, syntax 만 다른 것들과 동일  
  > [What do \"syntax\" and \"semantics\" mean and how are they different](http://www.jguru.com/faq/view.jsp?EID=81)  
  * Both models are **duals of each other**.  
    > a program written in one model can be mapped directly to an equivalent program based on the other model.  
    > 각기 다른 모델 간에 직접적인 매핑 시 똑같은 개념의 모델이 나옴  
  * Both models are **logically equivalent**  
    > although they use diverging concepts and provide a different syntax  
    > 논리적으로는 같음 (동시 처리라는 semantic은 공유하고 syntax가 다를 뿐임)  
  * The **performance** of programs written in both models is **essentially identical**  
    > 각각 사용하는 스케쥴링 전략 자체는 동일함  
    
#### mapping of both models (thread-based / event-driven)  
> 각기 다른 syntax를 구성하는, 각기 다른 building blocks  
> (하위에 추상화한 개념들 매핑)  
> LAUER, Hugh C. NEEDHAM, Roger M.:  
> On the duality of operating system structures. SIGOPS Oper. Syst. Rev. (1979),  13: 3-19  

* thread-based : event-driven  
* monitor : event handler
* scheduling : event loop  
* exported functions : event types accepted by event handler  
* returning from a procedure : dispatching a reply  
* executing a blocking procedure call : dispatching a message/awaiting a reply  
* waiting on condition variables : awaiting messages  

#### The flow of control in an application using either one of the models generates a unique graph  
> graph contains certain yielding or blocking nodes  
> (두 모델 모두 적용)  
> (awaiting a reply response / a procedure return)  

* 노드들 간의 첨점에 그래프 탐색을 위해 실행될 코드가 존재  
* 이원성 논증에 따라, 두 모델 모두 동일한 차단점 발생  
  > 같은 로직을 구현했고,    
  > 두 프로그램은 서로 이중성(서로 교환 가능)을 가지므로  
  
#### The logic is not affected and the semantic content of the code is thus invariant  
> 서로 간에 replacing concepts / transforming a program 할 경우  

* 위 내용들 가지고 유추해 보면, 적절한 실행 환경이 주어진다고 가정하면, 두 모델의 **성능까지도 같다고** 볼 수 있음  
  > 수평 확장 시, 편의성이 좀 다를 듯 / 근데 이건 지금 다루는 범위를 벗어남  
* 실제로 적용할 어플리케이션의 요구사항 특성에 따라, 모델을 결정해야 함  
* 둘 중 더 좋은 모델에 대해 일반화 된 정의를 만드는 것은 불가능 하고, 해서도 안됨  

#### 다른 프로그래밍 컨셉들과 event-based system 혼합 시, 추가 고려점 (mapping에 대해)  
> 실제 세계에선, 단일 모델 시스템으로 할 수 있는 거 거의 없음   
> mapping of both models 참고  
> 정의가 부족해짐, 보완해야할 점  
* ignore cooperative scheduling for event-based systems  
  * 하지만 오늘 날엔, 각각의 이벤트 기반 시스템들 끼리의 협업 관련 스케쥴링은 중요한 이슈  
  * "협업 관련 스케쥴링" : 개별 시스템들 간에 동기화 관련 된 이슈라고 보면 됨  
    > 모듈화된 시스템들로 전체 시스템을 구성  
    > 4.2 Server Architectures 에서 다룬 SEDA 생각  

* 위에 매핑은 공유 메모리나 글로벌 데이터에 대한 고려가 없음  
  * But many event-driven systems indeed use shared memory in a few places  
  * Immutable 데이터 컨셉으로 가는 이유 중 하나  
  * Immutability Changes Everything  
  

### A Case for Threads  

#### 스레드 지지자 : 스레드는 자연스러운 확장 형태임  
* 순차 처리 프로그래밍 스타일이 지배적임  
* 그런 스타일의 언어를 다루는 개발자에게 동시성을 제공할 때 스레드가 자연스러움    
  * 스레드는 **작업 자체의 관점**에 초점을 둠  
  * 스레드는 **주 제어 흐름과 함께 실행될 작업**을 매핑  
* 작업 완료를 위한 순차적인 단계에 초점을 맞추는 게 직관적이고, 스레드 개념이 이에 적합  

#### Transparently executing blocking operations and I/O calls  
* blocking operations & I/O calls 에 대해 확실한 보장을 주게 됨  
* 개발자는 이러한 하위 작업들에 대한 세부적인 스케쥴링에서 벗어날 수 있음  
  > 복잡도 완화  
* 하위 작업들에 대한 책임을 OS 와 runtime environment 에 넘김  
  > OS / runtime environment 에 의존하게 됨  
  > 일반적인 경우엔 괜찮지만, 특정 변경을 위해 OS / runtime environment 전체를 교체해야 함  
  > 문제를 해결하기 위해 6개의 동시 처리가 필요한데, 환경이 4개만 지원한다면 ?  
  > 그럴 때는 일이 더 커짐  
  
#### thread : Mandatory for exploiting true CPU concurrency  
* Threads are well-known and understood entities  
* 동시성에 대한 다른 접근법들도 결국에는 내부적으로 스레드 기반의 개념을 구현하고 있음  
  > 클라이언트(개발자)에게는 하이딩 하고 있지만 ...  
  
#### 동시 처리에 대한 스레드로의 추상화가 단순하고/강력하게 활용될 조건  
* tasks are mostly isolated  
* tasks only share a limited amount of state  

#### 스레드는 견고하고 구조화된 기본 syntax 개념을 제공  
> 동시처리 어플리케이션이 믿고 갈 수 있는 세계관  

#### thread-based 단점  
> [도형님글 thread-safe_보장작업](http://egloos.zum.com/aploit/v/5724750)  
> 단점 해결하기 첫 걸음임...  

* **extreme difficulty of developing correct concurrent code**  
  > even for programming experts  
  > 명확하긴 해도, 체크리스트가 많음  
  
* Coordination and Synchronization requires locking primitives (imperative)  
  > 문제를 해결하기 위한 방법을 구현하는 게, **문제 자체보다 더 복잡함**  
  
  * Erroneous locking introduces deadlocks or livelocks  
    > 잘못된 락킹 전략은 어플리케이션 전체를 망가뜨림  
    
  * 그렇다고, 올바른 락킹 선택 자체도 어려운 문제임   
    * **지나치게 느슨한 락킹 전략**  
      * 동시 처리 코드 속도 저하  
        > 락킹의 바운더리로 들어가기 전에 할 일이 많아짐  
        > 그 할 일들이 동시 처리될 애들임  
      * 순차적인 실행의 보장 수준이 저하됨  
    * **지나치게 엄격한 락킹 전략**  
      * 교착상태(deadlocks), livelocks 위험도 증가  
        > [경쟁상태, 교착상태, 라이브락](https://wonjayk.tistory.com/251)  
      * 락킹을 위한 오버헤드 증가  
    * Given two different components that are thread-safe, a composition of them is not thread-safe per se.  
    
* lack of understandability and predictability of multi-threaded code  
  > 비결정론 이랑 선제적 스케쥴링에 의존함   
  > 동시 처리도 어떤 면에서는 시퀀셜하게 실행될 수 있는데, 그 순서에 대해서 알 수 없고, 알아도 너무 복잡함  
  **This is primarily caused by the unpredicatability of preemptive scheduling**  
  * 합리적인 코드 분석이 불가능  
  * 이슈 발생 확율이 엄청 높은데  
  * 디버깅은 또 엄청 어려움  
  
  
### A Case for Events  

#### The fundamental idea : single-threaded event loop eases concurrency concerns  
> by providing a **simple, straight model of parallelism**  

#### 싱글 스레드 모델이지만, 블로킹/동기 I/O가 아니므로 I/O 작업은 겹침  
* 하지만, CPU 병렬에 대한 고려 없이 I/O에 대한 병렬만 고려할 수 있게됨  
* I/O 에 대한 병렬 처리 관리만 하면, 동시 처리를 **결정론적 추론** 기반으로 생각할 수 있게 해줌  
  * Event handler code and callbacks 는 상태에 대한 동시 접근을 배제 시켜줌  
  
#### 스케쥴링에 대한 부분이 어플리케이션 내부로 옮겨짐  
> 어플리케이션 단에서 세부적인 조절 가능  

#### Asynchronous style makes the differences between I/O operations and CPU bound operations
> Instead of giving the abstraction of an isolated sequential flow of executions  

#### IoC(Inversion of Control) 베이스라서 익숙하지 않은 개발자들에게 거부감을 줌  
* 시퀀셜한 작업이 아닌, event handler들에 대한 fragment set을 조립하는 방식  
  > 물어보지 말고, 메시지를 주는 형태로 해야함    
  > fragment set을 조립하는 방식 : 객체지향 설계 원칙들이 생각 났던 이유  

#### I/O 작업이 트리거 될 때마다, 분할된 다른 콜백에서 "비동기/논블록킹 I/O 처리에 대한 콜백 체인" 만들어야 함  

#### 상태 관리  
* 스레드 기반 일 때는 스케쥴링 상관없이, 스레드 스택에 상태값 저장 가능  
* 이벤트 드라이븐 일 때는 **이벤트 핸들러 간의 상태 제어/복구**에 대한 책임이 개발자에게 넘어감  
  > 복잡한 위 책임에 대해, 단순화 하기 위한 fundamental 개념으로  
  > pure function / immutable   
  
#### 실질적으로, CPU와 Core 수를 활용해서 동시성에 대해 큰 이점을 갖도록 구현하는 건 어려움  
> 하지만 I/O 이슈가 큰 개발 요구사항을 갖는 어플리케이션에서 I/O 처리를 고릾시켜서 생각할 수 있다는 게 큰듯  

#### (자바스크립트 기반) 웹 프론트엔드 개발 시 주로 이벤트-드라이븐 모델 쓰는 이유 찾음  
> 거의 모든 웹 클라이언트 어플리케이션의 기능들은 외부 자원(서버)들과의 I/O 가 필수적이니까  
> I/O 이슈가 가장 큼  
> 그래서 I/O 이슈에 대해서만 고립된 관점을 갖기 위해서 인듯 ....


