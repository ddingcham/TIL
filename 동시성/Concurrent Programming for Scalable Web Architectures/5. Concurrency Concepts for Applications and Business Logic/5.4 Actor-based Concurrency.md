# Concurrent Programming for Scalable Web Architectures  
# 5. Concurrency Concepts for Applications and Business Logic  

## 5.4 Actor-based Concurrency  

#### mutability and sharing of state are inherent for the complexities  
> not just inherent for models we have considered so far  

#### entirely different approach that bans the notion of shared state altogether  

#### State is still mutable, but exclusively coupled to single entities (Actor) that are allowed to alter it  

### The Actor Model  
* theoretical roots in  
  * concurrency modeling  
  * message passing concepts  

* fundamental idea : to use actors as **concurrent primitives that can act upon receiving messages**    
  * way 1] **Send a finite number of messages to other actors**  
  * way 2] **Spawn a finite number of new actors**  
  * way 3] **Change its own internal behavior, taking effect when the next incoming message is handled**  
  
* **asynchronous message passing** / for communication  
  > Vue 에서 기본적인 event/emit/props 만 사용해서 컴포넌트 간 통신하는 구조랑 유사  
  > address 제약 사항이 전체 어플리케이션 컴포넌트 트리에서의 직계 상/하위 컴포넌트에 제한되어 있는 거만 다름  
  * 일반적으로, 채널과 같은 중간 엔티티(컴포넌트)는 사용하지 않음  
  * 대신, 각각의 actor는 mailbox 소유, 주소 정의   
    * **These addresses are not to be confused with identities**  
    * each actor can have no, one or multiple addresses  
  * When an actor sends a message, it must know the address of the recipient  
  * 자기 자신에게도 메시지를 보낼 수 있으며, 메시지에 대한 응답은 비동기적  
    > they will receive and handle later in a future step  
  
* **Mapping of addresses and actors is not part of the conceptual model** (but feature of implementations)   
  > **다시**  
  > Vue 에서 기본적인 event/emit/props 만 사용해서 컴포넌트 간 통신하는 구조랑 유사  
  > address 제약 사항이 전체 어플리케이션 컴포넌트 트리에서의 직계 상/하위 컴포넌트에 제한되어 있는 거만 다름  

* network of several actors  
  * ![](http://berb.github.io/diploma-thesis/community/resources/actors.svg)  
  * Each actor has its own mailbox and isolated state  
  * Based on its designated behavior  
    * the actor responds to incoming messages by send new messages  
    * the actor spawn new actros and/or changing its future behavior  
    
* fundamental invariants    
  * Messages  
    * are sent asynchronously  
    * **can take arbitrarily long to eventually arrive in the mailbox of the receiver**  
  * **actor models makes no guarantees on the ordering of messages**  
  * Mailbox, Queueing and dequeuing of messages : **atomic operations -> no race condition**  
  * An actor processes incoming messages from his mailbox sequentially  
    > 큐에 보낸 순서대로 쌓여 있는 건지는 알 필요가 없음 // aforementioned possibilities to react  
  * changing its own internal behavior, eventually allows to deal with mutable state  
    * **However, the new behavior is only applied after the current message has been handled**  
    > 여기 까지에, data-driven / MVVM 이 합쳐지면 Vue 에서 기본적인 event/emit/props 만 사용해서 컴포넌트 간 통신하는 구조  
    > 어차피 액터(component)들 간에는 격리되 있고, 서로의 데이터에 대한 가시성은 직계 상위 컴포넌트의 props 로 제한  
  * **every message handling run still represents a side-effect free operation**  
    > from a conceptual perspective  
  
#### There is no shared state and the interaction between actors is purely based on asynchronous messages  
> 각각의 액터들은 다른 액터들에게 완벽하게 독립된 구조이므로  


  
  
