# Concurrent Programming for Scalable Web Architectures  
# 5. Concurrency Concepts for Applications and Business Logic  

## 5.5 Event-driven Concurrency  

Event-driven 프로그래밍이 동시성 모델 자체를 내포하는 건 아니지만,  
이벤트 루프 / 이벤트 핸들러 같은 개념과 구현은 동시 프로그래밍에 큰 영향을 미침  

**Event-driven 에서의 event/event-handler 개념이 actor/message 와 유사하다고 생각할 수 있지만**,  
**분명하게 구별해야 하는 점이 있음**  
  > 내가 어려워 하는 부분  
* Actor-based system  
  > actor-model이 모든 특성과 제약 조건을 갖도록 구현된다.  
* Event-driven system  
  > event/event-handler 를 빌딩 블록(의 프로토콜)으로 활용함.  
  > 호출 스택 개념 X  
  
### Event-driven Architectures  

소규모 어플리케이션의 구성요소 에서건, 대규모 분산 어플리케이션 에서건,
이벤트 주도 아키텍처는 특별한 형태의 실행 흐름을 갖음  
> 호출 스택 기반의 기존 시스템과 달리  

* **concept of a call stack**  
  * simple-flow  
    * caller invokes a method  
      * the invoked method in turn might have executed other methods on its own behalf  
    * then waits for the method to return  
    * finally, the caller continues with his next operation, **after his context has been restored**  
  * **call stack** : coordination / continuation / context   
    > a sequential execution order as a distinct series of maybe nested invocations  
  * 결정론적 특징 : caller knows in advance which methods are available and which services they expose  
  
#### event-driven architectures reject the concept of a call stack  
* call/return 대신 좀 더 표현적인 인터랙션 스타일을 제공  
* 더 느슨한 엔티티 간의 결합 제공  
* **event**  
  * occur through external stimuli  
  * are emitted by internal entities of the system  
  * can be consumed by other entities  
* **caller / callee(worker)** 간의 분리 : **caller는 callee 에 대한 "의존성이 완벽하게 없음"**  
  * 단순히 callee를 추상화된 대상으로 바라보는 걸 넘어서, 아예 몰라도 됨  
  * caller의 책임 자체가, 자신의 이벤트를 뿌리는 거에만 한정  
  * 그 이벤트가 어떻게 처리되는 지는 caller의 책임이 아님    
* **caller의 책임이 이벤트를 뿌리는 것에만 한정됨으로써 플로우 역시 바뀜**  
  * caller가 이벤트 처리 결과를 기다릴 필요가 없음 : asynchronous  
    > 누구한테 뿌렸는지, 어떤 처리가 있을 지 알지도 모르는 데  
* 이벤트 주도 아키텍처가 직접적으로 동시성 모델을 표방하는 건 아님  
  > 의존 관계를 끊어 줌으로써, 동시성 모델의 확장성 측면에서의 유리함을 제공  

