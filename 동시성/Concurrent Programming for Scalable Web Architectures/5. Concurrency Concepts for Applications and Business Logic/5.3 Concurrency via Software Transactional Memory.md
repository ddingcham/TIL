# Concurrent Programming for Scalable Web Architectures  
# 5. Concurrency Concepts for Applications and Business Logic  

## 5.3 Concurrency via Software Transactional Memory  

#### Indeterminacy and shared state requires a protection from race conditions  
* The concept of locks holds the developer responsible for guarding critical sections by explicitly placing locks  
  * Yielding unpredictable locking issues at runtime due to lock orders and indeterminacy  
  * composability of concurrent code is not guaranteed when locks are used  
  
* **higer abstractions for concurrent sections of code**  
  > provided programming languages  
  > locking becomes part of the underlying runtime environment  
  
### Transactional Memory  
> A lock-free alternative for shared state concurrency  

#### isolated operations is an established concept for database systems  
> HELLERSTEIN, Joseph M.; STONEBRAKER, Michael HAMILTON, James:  
> Architecture of a Database System, Now Publishers Inc., Hanover, MA, USA (2007)  

* **TM transactions read and write on state shared with other threads**  
  > While database transactions read and write on database rows  

* various ways to implement a concept of TM  
  * HTM  
    * hardware implementations of TM  
    * extends CPU architectures by transactional components  
      > such as transactional caches  
      > extended instruction set  
      
  * **STM**  
    * does not require any hardware changes and supports  
      > transaction handling entirely in software  
    * TM is primarily available in the form of STM  
      > due to high development and implementation costs of HTM  
  
  * **Hybrid TM is essentially an STM implementation**  
    * takes advantages of progressing hardware support for TM  
    * may eventually appear, **once this programming model has been established**  
    
#### Traditional transactions provide several guarantees  
* **guarantees // ACID**  
  * atomicity  
    > 원자성  
    > **트랜잭션으로 묶인 작업들을 원자적인 단위로 유지 : 올 패스 / 올 페일**  
  * consistency  
    > 일관성  
    > **트랜잭션이 실행이 성공적으로 완료되면, 데이터 베이스의 무결성 제약 준수를 통해 데이터의 일관성 유지**  
  * isolation  
    > 고립성  
    > 트랜잭션 수행 간 다른 트랜잭션 작업이 끼어들지 못하는 걸 보장  
    > 트랜잭션 외부에서는 중간 단계를 볼 수가 없음 "올 패스/올 페일" 된 결과만 볼 수있음  
    * isolation level  
      > 내려 갈수록 안정적이지만, 성능의 이슈가 생김 (동시/병렬에 대한 병목 지점)    
      > [MySQL 트랜잭션 Isolation Level로 인한 장애 사전 예방 법 1](http://gywn.net/2012/05/mysql-transaction-isolation-level/#comments)  
      > [MySQL 트랜잭션 Isolation Level로 인한 장애 사전 예방 법 2](http://gywn.net/2012/10/mysql-transaction-isolation-level2/)  
      * Read Uncommitted  
        > 트랜잭션이 안 끝났어도, 읽기는 가능  
        > 어플리케이션의 특성 상 **데이터 조회 일관성**에 대한 가치가 중요하지 않다면 ...  
      * Read Committed  
        > 트랜잭션이 끝나야(commit), 읽기 가능  
        > **조회 시에도 데이터가 Shared lock**  
      * Repeatable Read  
        > Transaction 벙위 내에서는 **조회한 데이터의 내용에 대해 동일성 보장**  
        * ex] [참고](https://medium.com/@wonderful.dev/isolation-level-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-94e2c30cd8c9)            
      * Serializable  
  * durability  
    > 내구성  
    > 수행된 트랜잭션은 영원히 반영되어야 함  
    * **일반적으로, 모든 트랜잭션을 로그로 남김**  
      * 시스템 장애로 인해 롤백이 필요할 시 활용  
      * commit 에 대한 판단 조건 역시 **로그에 모든 것이 저장되어 있는가**  
        > isolation level 판단 조건과 묶어서 그림 그려야 함  
      
#### durability differes from transactions for database systems and TM  
* **TM : 트랜잭션 결과를 메모리에 유지는 하지만, 응용 프로그램 충돌로 휘발되면 상태 복구 불가**    
  > Transactional **Memory**  
  > serializable은 가능  
* 따라서, 트랜잭션 결과는 "원자적 연산(내부적으로는 아닐 수 있음)"들을 같은 순서로 재 실행해야 복구 가능  

#### Transactional Memory 구체적인 느낌 필요 시  
> TM 개념 활용하는 익숙한 오픈소스 확인  
* [CHAPTER 11. JAVA TRANSACTION API \(JTA\)](https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html/development_guide/java_transaction_api_jta#about_java_transactions_api_jta)    
* [jboss/hibernate/Transactions and concurrency control](https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/chapters/transactions/Transactions.html)  
    
    
#### 비관적 동시성 제어는 보수적인 형태 : 트랜잭션 처리량이 낮음 (안정적일 수록 느림)      
> 충돌 자체를 피하자  
#### 실행 시간이 짧고, 예상 충돌 횟수가 크지 않으면, 낙관적인 동시성 제어가 성능상 유리  
> 재수행을 위한 오버헤드가 무시할만큼 작을 때  
> 충돌 횟수도 많지 않고 + 충돌 패널티가 크지 않다면, 차라리 충돌 시키고 재수행하자  

